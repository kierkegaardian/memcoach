{% extends "base.html" %}

{% block title %}Review {{ deck.name }} for {{ kid.name }} - MemCoach{% endblock %}

{% block extra_head %}
<style>
    .prompt-large {
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.4;
        margin-bottom: 1rem;
        color: #1e40af;
    }
    .recall-textarea {
        font-size: 1.2rem;
        line-height: 1.5;
        border: 2px solid #e5e7eb;
        transition: border-color 0.2s;
    }
    .recall-textarea:focus {
        border-color: #3b82f6;
        outline: none;
    }
</style>
{% endblock %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <h2 class="text-3xl font-bold mb-6">Review Session: {{ deck.name }} for {{ kid.name }}</h2>
    <p class="text-gray-600 mb-4">
        Pick a hint style for this session: no hints, first letters, every Nth word, or line-by-line.
    </p>
    <div class="mb-4 bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm text-gray-700">
        <span class="font-medium">Chunk grouping:</span>
        {% if group_texts %}
            <span class="ml-2">On</span>
            <a href="/review/{{ kid_id }}/{{ deck_id }}" class="ml-3 text-blue-600 hover:underline">Turn off</a>
        {% else %}
            <span class="ml-2">Off</span>
            <a href="/review/{{ kid_id }}/{{ deck_id }}?group_texts=1" class="ml-3 text-blue-600 hover:underline">Turn on</a>
        {% endif %}
    </div>
    <div class="mb-6 border rounded-lg p-4 bg-gray-50 space-y-3">
        <div>
            <p class="text-sm font-semibold text-gray-700">Filter today's cards</p>
            <p class="text-xs text-gray-500">Search prompt/full text or narrow by tags.</p>
        </div>
        <form method="get" action="/review/{{ kid_id }}/{{ deck_id }}" class="space-y-3">
            <input type="hidden" name="deck_id" value="{{ deck_id }}">
            <input type="hidden" name="kid_id" value="{{ kid_id }}">
            <input type="hidden" name="due_today" value="1">
            <input type="hidden" name="apply_filters" value="1">
            {% if group_texts %}
                <input type="hidden" name="group_texts" value="1">
            {% endif %}
            <input
                type="text"
                name="q"
                placeholder="Search today's cards..."
                class="w-full border border-gray-300 rounded px-3 py-2"
                value="{{ search_query }}"
                hx-get="/search"
                hx-target="#today-search-results"
                hx-trigger="keyup changed delay:300ms"
                hx-include="closest form"
            >
            {% if deck_tags %}
                <div class="flex flex-wrap gap-3">
                    {% for tag in deck_tags %}
                        <label class="flex items-center gap-2 text-sm text-gray-700">
                            <input
                                type="checkbox"
                                name="tag"
                                value="{{ tag }}"
                                class="rounded border-gray-300"
                                {% if tag in selected_tags %}checked{% endif %}
                                hx-get="/search"
                                hx-target="#today-search-results"
                                hx-trigger="change"
                                hx-include="closest form"
                            >
                            <span>{{ tag }}</span>
                        </label>
                    {% endfor %}
                </div>
            {% endif %}
            <div class="flex flex-wrap items-center gap-3 text-sm">
                <button type="submit" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600">Apply filters to session</button>
                {% if apply_filters or search_query or selected_tags %}
                    <a href="/review/{{ kid_id }}/{{ deck_id }}{% if group_texts %}?group_texts=1{% endif %}" class="text-blue-600 hover:underline">Clear</a>
                {% endif %}
                {% if apply_filters %}
                    <span class="text-xs uppercase tracking-wide text-green-600">Filters active</span>
                {% endif %}
            </div>
        </form>
        <div id="today-search-results" class="text-sm text-gray-600">
            <p class="text-sm text-gray-500">Start typing or select tags to filter.</p>
        </div>
    </div>
    <div id="result"></div>
    <div id="card-container">
        {% if card %}
            {% include "partials/card.html" %}
        {% else %}
            {% include "partials/no_cards.html" %}
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Optional kid-friendly sound or animation on submit
    document.body.addEventListener('htmx:afterRequest', function(e) {
        if (e.detail.xhr.status === 200) {
            // Play success sound or confetti if bonus
            console.log('Card reviewed!');
        }
    });
</script>
<script>
    (function () {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            document.querySelectorAll('.voice-status').forEach((el) => {
                el.textContent = 'Voice input not supported in this browser.';
            });
            document.querySelectorAll('.voice-preview').forEach((el) => {
                el.textContent = '';
            });
            return;
        }

        const recognizer = new SpeechRecognition();
        recognizer.lang = 'en-US';
        recognizer.interimResults = true;
        recognizer.continuous = true;

        let activeButton = null;
        let activeStatus = null;
        let activeInput = null;
        let activePreview = null;
        let finalTranscript = '';
        let shouldListen = false;
        let restartTimer = null;
        let activeLocalButton = null;
        let activeLocalStatus = null;
        let activeLocalInput = null;
        let activeLocalPreview = null;
        let localRecorder = null;
        let localStream = null;
        let localChunks = [];

        const setStatus = (message) => {
            if (activeStatus) {
                activeStatus.textContent = message;
            }
        };

        const setPreview = (message) => {
            if (activePreview) {
                activePreview.textContent = message;
            }
        };

        const setButtonLabel = (label) => {
            if (activeButton) {
                activeButton.textContent = label;
            }
        };

        const setLocalStatus = (message) => {
            if (activeLocalStatus) {
                activeLocalStatus.textContent = message;
            }
        };

        const setLocalButtonLabel = (label) => {
            if (activeLocalButton) {
                activeLocalButton.textContent = label;
            }
        };

        const resetState = () => {
            activeButton = null;
            activeStatus = null;
            activeInput = null;
            activePreview = null;
            finalTranscript = '';
        };

        const resetLocalState = () => {
            activeLocalButton = null;
            activeLocalStatus = null;
            activeLocalInput = null;
            activeLocalPreview = null;
            localRecorder = null;
            localStream = null;
            localChunks = [];
        };

        const clearRestart = () => {
            if (restartTimer) {
                window.clearTimeout(restartTimer);
                restartTimer = null;
            }
        };

        const startRecognizer = () => {
            clearRestart();
            if (!shouldListen) {
                return;
            }
            try {
                recognizer.start();
            } catch (err) {
                if (err && err.name === 'InvalidStateError') {
                    return;
                }
                setStatus(`Voice input error: ${err?.message || err}`);
                setButtonLabel('ðŸŽ™ï¸ Start voice input');
                shouldListen = false;
                resetState();
            }
        };

        const stopRecognizer = () => {
            shouldListen = false;
            clearRestart();
            try {
                recognizer.stop();
            } catch (err) {
                // Ignore stop errors when recognition is already ending.
            }
        };

        const getSupportedMimeType = () => {
            const candidates = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg;codecs=opus',
            ];
            for (const candidate of candidates) {
                if (window.MediaRecorder && MediaRecorder.isTypeSupported(candidate)) {
                    return candidate;
                }
            }
            return '';
        };

        const cleanupLocalStream = () => {
            if (localStream) {
                localStream.getTracks().forEach((track) => track.stop());
            }
            localStream = null;
        };

        const stopLocalRecording = () => {
            if (!localRecorder) {
                return;
            }
            try {
                if (localRecorder.state === 'recording' && localRecorder.requestData) {
                    localRecorder.requestData();
                }
                localRecorder.stop();
            } catch (err) {
                // Ignore stop errors if recorder already stopped.
            }
        };

        recognizer.onstart = () => {
            setStatus('Listening... Speak now.');
            setPreview('');
            setButtonLabel('ðŸ›‘ Stop voice input');
        };

        recognizer.onresult = (event) => {
            let interim = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcript + ' ';
                } else {
                    interim += transcript;
                }
            }
            if (activeInput) {
                const combined = (finalTranscript + interim).trim();
                activeInput.value = combined;
                if (combined) {
                    const previewText = combined.length > 120 ? `${combined.slice(0, 117)}â€¦` : combined;
                    setPreview(`Heard: ${previewText}`);
                } else {
                    setPreview('');
                }
            }
        };

        recognizer.onerror = (event) => {
            if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                setStatus('Microphone access denied.');
                setPreview('');
                setButtonLabel('ðŸŽ™ï¸ Start voice input');
                stopRecognizer();
                resetState();
                return;
            }
            setStatus(`Voice input error: ${event.error}`);
            setPreview('');
        };

        recognizer.onend = () => {
            if (shouldListen) {
                setStatus('Listening...');
                restartTimer = window.setTimeout(startRecognizer, 250);
                return;
            }
            setStatus(finalTranscript ? 'Transcription ready.' : 'Voice input stopped.');
            setPreview(finalTranscript ? 'Transcript ready.' : '');
            setButtonLabel('ðŸŽ™ï¸ Start voice input');
            resetState();
        };

        document.addEventListener('click', (event) => {
            const button = event.target.closest('.voice-btn');
            if (!button) {
                return;
            }
            event.preventDefault();

            if (activeButton && !document.body.contains(activeButton)) {
                stopRecognizer();
                resetState();
            }

            if (activeButton) {
                stopRecognizer();
                setStatus('Voice input stopped.');
                setPreview('');
                setButtonLabel('ðŸŽ™ï¸ Start voice input');
                resetState();
                return;
            }

            const container = button.closest('form') || document;
            const targetName = button.dataset.voiceTarget;
            const input = container.querySelector(`[name="${targetName}"]`);
            const status = button.parentElement.querySelector('.voice-status');
            const preview = button.parentElement.querySelector('.voice-preview');

            if (!input) {
                return;
            }

            activeButton = button;
            activeStatus = status;
            activeInput = input;
            activePreview = preview;
            finalTranscript = input.value ? input.value + ' ' : '';
            shouldListen = true;

            setStatus('Starting mic...');
            setPreview('');
            startRecognizer();
        });

        document.addEventListener('click', async (event) => {
            const button = event.target.closest('.voice-local-btn');
            if (!button) {
                return;
            }
            event.preventDefault();

            if (activeLocalButton && !document.body.contains(activeLocalButton)) {
                stopLocalRecording();
                cleanupLocalStream();
                resetLocalState();
            }

            if (activeLocalButton) {
                setLocalStatus('Transcribing locally...');
                setLocalButtonLabel('ðŸŽ§ Record & transcribe');
                stopLocalRecording();
                return;
            }

            const container = button.closest('form') || document;
            const targetName = button.dataset.voiceTarget;
            const input = container.querySelector(`[name="${targetName}"]`);
            const status = button.parentElement.querySelector('.voice-local-status');
            const preview = button.parentElement.querySelector('.voice-preview');

            if (!input) {
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                if (status) {
                    status.textContent = 'Local recording not supported in this browser.';
                }
                return;
            }

            if (activeButton) {
                stopRecognizer();
                resetState();
            }

            activeLocalButton = button;
            activeLocalStatus = status;
            activeLocalInput = input;
            activeLocalPreview = preview;
            localChunks = [];

            setLocalStatus('Starting local recorder...');
            setLocalButtonLabel('â¹ Stop & transcribe');
            if (activeLocalPreview) {
                activeLocalPreview.textContent = '';
            }

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mimeType = getSupportedMimeType();
                localRecorder = mimeType
                    ? new MediaRecorder(localStream, { mimeType })
                    : new MediaRecorder(localStream);
            } catch (err) {
                setLocalStatus('Microphone access denied.');
                setLocalButtonLabel('ðŸŽ§ Record & transcribe');
                cleanupLocalStream();
                resetLocalState();
                return;
            }

            localRecorder.ondataavailable = (evt) => {
                if (evt.data && evt.data.size > 0) {
                    localChunks.push(evt.data);
                }
            };

            localRecorder.onstop = async () => {
                cleanupLocalStream();
                const blobType = localRecorder.mimeType || 'audio/webm';
                const blob = new Blob(localChunks, { type: blobType });
                const ext = blobType.includes('ogg') ? 'ogg' : 'webm';
                const formData = new FormData();
                formData.append('audio', blob, `recording.${ext}`);
                setLocalStatus('Transcribing locally...');
                try {
                    const response = await fetch('/stt', {
                        method: 'POST',
                        body: formData,
                    });
                    const payload = await response.json().catch(() => ({}));
                    if (!response.ok) {
                        setLocalStatus(payload.detail || 'Transcription failed.');
                        setLocalButtonLabel('ðŸŽ§ Record & transcribe');
                        resetLocalState();
                        return;
                    }
                    const text = (payload.text || '').trim();
                    if (activeLocalInput) {
                        activeLocalInput.value = text;
                    }
                    if (activeLocalPreview) {
                        activeLocalPreview.textContent = text ? `Heard: ${text}` : '';
                    }
                    setLocalStatus(text ? 'Local transcript ready.' : 'No speech detected.');
                } catch (err) {
                    setLocalStatus('Transcription failed.');
                }
                setLocalButtonLabel('ðŸŽ§ Record & transcribe');
                resetLocalState();
            };

            localRecorder.start(250);
            setLocalStatus('Recording... Tap stop when done.');
        });
    })();
</script>
{% endblock %}
