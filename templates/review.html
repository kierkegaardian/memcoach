{% extends "base.html" %}

{% block title %}Review {{ deck.name }} for {{ kid.name }} - MemCoach{% endblock %}

{% block extra_head %}
<style>
    .prompt-large {
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.4;
        margin-bottom: 1rem;
        color: #1e40af;
    }
    .recall-textarea {
        font-size: 1.2rem;
        line-height: 1.5;
        border: 2px solid #e5e7eb;
        transition: border-color 0.2s;
    }
    .recall-textarea:focus {
        border-color: #3b82f6;
        outline: none;
    }
</style>
{% endblock %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <h2 class="text-3xl font-bold mb-6">Review Session: {{ deck.name }} for {{ kid.name }}</h2>
    <p class="text-gray-600 mb-4">
        Pick a hint style for this session: no hints, first letters, every Nth word, or line-by-line.
    </p>
    <div class="mb-4 bg-gray-50 border border-gray-200 rounded-lg p-3 text-sm text-gray-700">
        <span class="font-medium">Chunk grouping:</span>
        {% if group_texts %}
            <span class="ml-2">On</span>
            <a href="/review/{{ kid_id }}/{{ deck_id }}" class="ml-3 text-blue-600 hover:underline">Turn off</a>
        {% else %}
            <span class="ml-2">Off</span>
            <a href="/review/{{ kid_id }}/{{ deck_id }}?group_texts=1" class="ml-3 text-blue-600 hover:underline">Turn on</a>
        {% endif %}
    </div>
    <div class="mb-6 border rounded-lg p-4 bg-gray-50 space-y-3">
        <div>
            <p class="text-sm font-semibold text-gray-700">Filter today's cards</p>
            <p class="text-xs text-gray-500">Search prompt/full text or narrow by tags.</p>
        </div>
        <form method="get" action="/review/{{ kid_id }}/{{ deck_id }}" class="space-y-3">
            <input type="hidden" name="deck_id" value="{{ deck_id }}">
            <input type="hidden" name="kid_id" value="{{ kid_id }}">
            <input type="hidden" name="due_today" value="1">
            <input type="hidden" name="apply_filters" value="1">
            {% if group_texts %}
                <input type="hidden" name="group_texts" value="1">
            {% endif %}
            <input
                type="text"
                name="q"
                placeholder="Search today's cards..."
                class="w-full border border-gray-300 rounded px-3 py-2"
                value="{{ search_query }}"
                hx-get="/search"
                hx-target="#today-search-results"
                hx-trigger="keyup changed delay:300ms"
                hx-include="closest form"
            >
            {% if deck_tags %}
                <div class="flex flex-wrap gap-3">
                    {% for tag in deck_tags %}
                        <label class="flex items-center gap-2 text-sm text-gray-700">
                            <input
                                type="checkbox"
                                name="tag"
                                value="{{ tag }}"
                                class="rounded border-gray-300"
                                {% if tag in selected_tags %}checked{% endif %}
                                hx-get="/search"
                                hx-target="#today-search-results"
                                hx-trigger="change"
                                hx-include="closest form"
                            >
                            <span>{{ tag }}</span>
                        </label>
                    {% endfor %}
                </div>
            {% endif %}
            <div class="flex flex-wrap items-center gap-3 text-sm">
                <button type="submit" class="bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600">Apply filters to session</button>
                {% if apply_filters or search_query or selected_tags %}
                    <a href="/review/{{ kid_id }}/{{ deck_id }}{% if group_texts %}?group_texts=1{% endif %}" class="text-blue-600 hover:underline">Clear</a>
                {% endif %}
                {% if apply_filters %}
                    <span class="text-xs uppercase tracking-wide text-green-600">Filters active</span>
                {% endif %}
            </div>
        </form>
        <div id="today-search-results" class="text-sm text-gray-600">
            <p class="text-sm text-gray-500">Start typing or select tags to filter.</p>
        </div>
    </div>
    <div id="result"></div>
    <div id="card-container">
        {% if card %}
            {% include "partials/card.html" %}
        {% else %}
            {% include "partials/no_cards.html" %}
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Optional kid-friendly sound or animation on submit
    document.body.addEventListener('htmx:afterRequest', function(e) {
        if (e.detail.xhr.status === 200) {
            // Play success sound or confetti if bonus
            console.log('Card reviewed!');
        }
    });
</script>
<script>
    (function () {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            document.querySelectorAll('.voice-status').forEach((el) => {
                el.textContent = 'Voice input not supported in this browser.';
            });
            document.querySelectorAll('.voice-preview').forEach((el) => {
                el.textContent = '';
            });
        }

        const recognizer = SpeechRecognition ? new SpeechRecognition() : null;
        if (recognizer) {
            recognizer.lang = 'en-US';
            recognizer.interimResults = true;
            recognizer.continuous = true;
        }

        let activeButton = null;
        let activeStatus = null;
        let activeInput = null;
        let activePreview = null;
        let finalTranscript = '';
        let shouldListen = false;
        let restartTimer = null;
        let activeLocalButton = null;
        let activeLocalStatus = null;
        let activeLocalInput = null;
        let activeLocalPreview = null;
        let localRecorder = null;
        let localStream = null;
        let localChunks = [];
        let activeMeterBar = null;
        let meterAnimation = null;
        let meterAudioContext = null;
        let meterAnalyser = null;
        let meterSource = null;
        let meterStream = null;
        let meterOwnsStream = false;
        let activeMonitorButton = null;
        let activeMonitorStatus = null;

        const setStatus = (message) => {
            if (activeStatus) {
                activeStatus.textContent = message;
            }
        };

        const setPreview = (message) => {
            if (activePreview) {
                activePreview.textContent = message;
            }
        };

        const setButtonLabel = (label) => {
            if (activeButton) {
                activeButton.textContent = label;
            }
        };

        const setLocalStatus = (message) => {
            if (activeLocalStatus) {
                activeLocalStatus.textContent = message;
            }
        };

        const setLocalButtonLabel = (label) => {
            if (activeLocalButton) {
                activeLocalButton.textContent = label;
            }
        };

        const resetState = () => {
            activeButton = null;
            activeStatus = null;
            activeInput = null;
            activePreview = null;
            finalTranscript = '';
        };

        const resetLocalState = () => {
            activeLocalButton = null;
            activeLocalStatus = null;
            activeLocalInput = null;
            activeLocalPreview = null;
            localRecorder = null;
            localStream = null;
            localChunks = [];
        };

        const stopMeter = () => {
            if (meterAnimation) {
                window.cancelAnimationFrame(meterAnimation);
                meterAnimation = null;
            }
            if (meterSource) {
                meterSource.disconnect();
                meterSource = null;
            }
            if (meterAnalyser) {
                meterAnalyser.disconnect();
                meterAnalyser = null;
            }
            if (meterAudioContext) {
                meterAudioContext.close().catch(() => {});
                meterAudioContext = null;
            }
            if (meterStream && meterOwnsStream) {
                meterStream.getTracks().forEach((track) => track.stop());
            }
            meterStream = null;
            meterOwnsStream = false;
            if (activeMeterBar) {
                activeMeterBar.style.width = '0%';
            }
            activeMeterBar = null;
        };

        const startMeter = (stream, meterBar, ownsStream) => {
            stopMeter();
            if (!stream || !meterBar) {
                if (ownsStream && stream) {
                    stream.getTracks().forEach((track) => track.stop());
                }
                return;
            }
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) {
                if (ownsStream) {
                    stream.getTracks().forEach((track) => track.stop());
                }
                return;
            }
            activeMeterBar = meterBar;
            meterOwnsStream = ownsStream;
            meterStream = stream;
            meterAudioContext = new AudioContext();
            meterAnalyser = meterAudioContext.createAnalyser();
            meterAnalyser.fftSize = 2048;
            meterSource = meterAudioContext.createMediaStreamSource(stream);
            meterSource.connect(meterAnalyser);
            const data = new Uint8Array(meterAnalyser.fftSize);
            const tick = () => {
                meterAnalyser.getByteTimeDomainData(data);
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    const value = (data[i] - 128) / 128;
                    sum += value * value;
                }
                const rms = Math.sqrt(sum / data.length);
                const level = Math.min(1, rms * 3);
                if (activeMeterBar) {
                    activeMeterBar.style.width = `${Math.round(level * 100)}%`;
                }
                meterAnimation = window.requestAnimationFrame(tick);
            };
            tick();
        };

        const stopMonitor = () => {
            if (!activeMonitorButton) {
                return;
            }
            activeMonitorButton.textContent = 'üéöÔ∏è Test mic';
            if (activeMonitorStatus) {
                activeMonitorStatus.textContent = 'Mic monitor stopped.';
            }
            activeMonitorButton = null;
            activeMonitorStatus = null;
            stopMeter();
        };

        const refreshMicOptions = async () => {
            const selects = document.querySelectorAll('.mic-select');
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                selects.forEach((select) => {
                    select.innerHTML = '<option value="">Microphone list unavailable</option>';
                    select.disabled = true;
                });
                return;
            }
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const inputs = devices.filter((device) => device.kind === 'audioinput');
                selects.forEach((select) => {
                    const currentValue = select.value;
                    select.innerHTML = '';
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = 'Default microphone';
                    select.appendChild(defaultOption);
                    inputs.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `Microphone ${index + 1}`;
                        select.appendChild(option);
                    });
                    if (currentValue && inputs.some((device) => device.deviceId === currentValue)) {
                        select.value = currentValue;
                    }
                    select.disabled = inputs.length === 0;
                });
            } catch (err) {
                // Ignore device enumeration errors.
            }
        };

        const getMicConstraints = (deviceId) => {
            if (!deviceId) {
                return { audio: true };
            }
            return {
                audio: {
                    deviceId: { exact: deviceId },
                },
            };
        };

        refreshMicOptions();
        if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
            navigator.mediaDevices.addEventListener('devicechange', refreshMicOptions);
        }
        document.body.addEventListener('htmx:afterSwap', () => {
            refreshMicOptions();
        });

        const clearRestart = () => {
            if (restartTimer) {
                window.clearTimeout(restartTimer);
                restartTimer = null;
            }
        };

        const startRecognizer = () => {
            clearRestart();
            if (!shouldListen) {
                return;
            }
            if (!recognizer) {
                setStatus('Voice input not supported in this browser.');
                shouldListen = false;
                return;
            }
            try {
                recognizer.start();
            } catch (err) {
                if (err && err.name === 'InvalidStateError') {
                    return;
                }
                setStatus(`Voice input error: ${err?.message || err}`);
                setButtonLabel('üéôÔ∏è Start voice input');
                shouldListen = false;
                resetState();
            }
        };

        const stopRecognizer = () => {
            shouldListen = false;
            clearRestart();
            if (!recognizer) {
                return;
            }
            try {
                recognizer.stop();
            } catch (err) {
                // Ignore stop errors when recognition is already ending.
            }
        };

        const getSupportedMimeType = () => {
            const candidates = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg;codecs=opus',
            ];
            for (const candidate of candidates) {
                if (window.MediaRecorder && MediaRecorder.isTypeSupported(candidate)) {
                    return candidate;
                }
            }
            return '';
        };

        const cleanupLocalStream = () => {
            if (localStream) {
                localStream.getTracks().forEach((track) => track.stop());
            }
            localStream = null;
        };

        const stopLocalRecording = () => {
            if (!localRecorder) {
                return;
            }
            try {
                if (localRecorder.state === 'recording' && localRecorder.requestData) {
                    localRecorder.requestData();
                }
                localRecorder.stop();
            } catch (err) {
                // Ignore stop errors if recorder already stopped.
            }
        };

        if (recognizer) {
            recognizer.onstart = () => {
                setStatus('Listening... Speak now.');
                setPreview('');
                setButtonLabel('üõë Stop voice input');
            };

            recognizer.onresult = (event) => {
                let interim = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interim += transcript;
                    }
                }
                if (activeInput) {
                    const combined = (finalTranscript + interim).trim();
                    activeInput.value = combined;
                    if (combined) {
                        const previewText = combined.length > 120 ? `${combined.slice(0, 117)}‚Ä¶` : combined;
                        setPreview(`Heard: ${previewText}`);
                    } else {
                        setPreview('');
                    }
                }
            };

            recognizer.onerror = (event) => {
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    setStatus('Microphone access denied.');
                    setPreview('');
                    setButtonLabel('üéôÔ∏è Start voice input');
                    stopRecognizer();
                    resetState();
                    return;
                }
                setStatus(`Voice input error: ${event.error}`);
                setPreview('');
            };

            recognizer.onend = () => {
                if (shouldListen) {
                    setStatus('Listening...');
                    restartTimer = window.setTimeout(startRecognizer, 250);
                    return;
                }
                setStatus(finalTranscript ? 'Transcription ready.' : 'Voice input stopped.');
                setPreview(finalTranscript ? 'Transcript ready.' : '');
                setButtonLabel('üéôÔ∏è Start voice input');
                resetState();
            };
        }

        document.addEventListener('click', (event) => {
            const button = event.target.closest('.voice-btn');
            if (!button) {
                return;
            }
            event.preventDefault();

            if (activeButton && !document.body.contains(activeButton)) {
                stopRecognizer();
                resetState();
            }

            if (activeButton) {
                stopRecognizer();
                setStatus('Voice input stopped.');
                setPreview('');
                setButtonLabel('üéôÔ∏è Start voice input');
                resetState();
                return;
            }

            const container = button.closest('form') || document;
            const targetName = button.dataset.voiceTarget;
            const input = container.querySelector(`[name="${targetName}"]`);
            const controls = button.closest('.voice-controls') || button.parentElement;
            const status = controls ? controls.querySelector('.voice-status') : null;
            const preview = controls ? controls.querySelector('.voice-preview') : null;

            if (!input) {
                return;
            }
            if (!recognizer) {
                if (status) {
                    status.textContent = 'Voice input not supported in this browser.';
                }
                if (preview) {
                    preview.textContent = '';
                }
                return;
            }

            activeButton = button;
            activeStatus = status;
            activeInput = input;
            activePreview = preview;
            finalTranscript = input.value ? input.value + ' ' : '';
            shouldListen = true;

            setStatus('Starting mic...');
            setPreview('');
            startRecognizer();
        });

        document.addEventListener('click', async (event) => {
            const button = event.target.closest('.voice-local-btn');
            if (!button) {
                return;
            }
            event.preventDefault();

            if (activeLocalButton && !document.body.contains(activeLocalButton)) {
                stopLocalRecording();
                cleanupLocalStream();
                stopMeter();
                resetLocalState();
            }

            if (activeLocalButton) {
                setLocalStatus('Transcribing locally...');
                setLocalButtonLabel('üéß Record & transcribe');
                stopLocalRecording();
                return;
            }

            const container = button.closest('form') || document;
            const targetName = button.dataset.voiceTarget;
            const input = container.querySelector(`[name="${targetName}"]`);
            const controls = button.closest('.voice-controls') || button.parentElement;
            const status = controls ? controls.querySelector('.voice-local-status') : null;
            const preview = controls ? controls.querySelector('.voice-preview') : null;
            const micSelect = controls ? controls.querySelector('.mic-select') : null;
            const meterBar = controls ? controls.querySelector('.mic-meter-bar') : null;

            if (!input) {
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                if (status) {
                    status.textContent = 'Local recording not supported in this browser.';
                }
                return;
            }

            if (activeButton) {
                stopRecognizer();
                resetState();
            }
            stopMonitor();

            activeLocalButton = button;
            activeLocalStatus = status;
            activeLocalInput = input;
            activeLocalPreview = preview;
            localChunks = [];

            setLocalStatus('Starting local recorder...');
            setLocalButtonLabel('‚èπ Stop & transcribe');
            if (activeLocalPreview) {
                activeLocalPreview.textContent = '';
            }

            try {
                const constraints = getMicConstraints(micSelect ? micSelect.value : '');
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                refreshMicOptions();
                const mimeType = getSupportedMimeType();
                localRecorder = mimeType
                    ? new MediaRecorder(localStream, { mimeType })
                    : new MediaRecorder(localStream);
                startMeter(localStream, meterBar, false);
            } catch (err) {
                setLocalStatus('Microphone access denied.');
                setLocalButtonLabel('üéß Record & transcribe');
                cleanupLocalStream();
                stopMeter();
                resetLocalState();
                return;
            }

            localRecorder.ondataavailable = (evt) => {
                if (evt.data && evt.data.size > 0) {
                    localChunks.push(evt.data);
                }
            };

            localRecorder.onstop = async () => {
                cleanupLocalStream();
                stopMeter();
                const blobType = localRecorder.mimeType || 'audio/webm';
                const blob = new Blob(localChunks, { type: blobType });
                const ext = blobType.includes('ogg') ? 'ogg' : 'webm';
                const formData = new FormData();
                formData.append('audio', blob, `recording.${ext}`);
                setLocalStatus('Transcribing locally...');
                try {
                    const response = await fetch('/stt', {
                        method: 'POST',
                        body: formData,
                    });
                    const payload = await response.json().catch(() => ({}));
                    if (!response.ok) {
                        setLocalStatus(payload.detail || 'Transcription failed.');
                        setLocalButtonLabel('üéß Record & transcribe');
                        resetLocalState();
                        return;
                    }
                    const text = (payload.text || '').trim();
                    if (activeLocalInput) {
                        activeLocalInput.value = text;
                    }
                    if (activeLocalPreview) {
                        activeLocalPreview.textContent = text ? `Heard: ${text}` : '';
                    }
                    setLocalStatus(text ? 'Local transcript ready.' : 'No speech detected.');
                } catch (err) {
                    setLocalStatus('Transcription failed.');
                }
                setLocalButtonLabel('üéß Record & transcribe');
                resetLocalState();
            };

            localRecorder.start(250);
            setLocalStatus('Recording... Tap stop when done.');
        });

        document.addEventListener('click', async (event) => {
            const button = event.target.closest('.mic-monitor-btn');
            if (!button) {
                return;
            }
            event.preventDefault();

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                return;
            }

            const controls = button.closest('.voice-controls') || button.parentElement;
            const status = controls ? controls.querySelector('.voice-local-status') : null;
            const micSelect = controls ? controls.querySelector('.mic-select') : null;
            const meterBar = controls ? controls.querySelector('.mic-meter-bar') : null;

            if (activeLocalButton) {
                if (status) {
                    status.textContent = 'Stop recording to test mic.';
                }
                return;
            }

            if (activeMonitorButton === button) {
                stopMonitor();
                return;
            }
            if (activeMonitorButton) {
                stopMonitor();
            }

            activeMonitorButton = button;
            activeMonitorStatus = status;
            button.textContent = '‚èπ Stop mic test';
            if (status) {
                status.textContent = 'Mic monitor active.';
            }

            try {
                const constraints = getMicConstraints(micSelect ? micSelect.value : '');
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                refreshMicOptions();
                startMeter(stream, meterBar, true);
            } catch (err) {
                if (status) {
                    status.textContent = 'Microphone access denied.';
                }
                button.textContent = 'üéöÔ∏è Test mic';
                activeMonitorButton = null;
                activeMonitorStatus = null;
            }
        });
    })();
</script>
{% endblock %}
